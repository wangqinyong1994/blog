<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>React原理 | 王秦勇的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="React中文官网 有两类场景会制约快速响应  当遇到大计算量的操作或设备性能不足使页面掉帧，导致卡顿。 发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。  概括为：CPU 瓶颈、IO 瓶颈 解决 CPU 瓶颈 js 可以操作 DOM，GUI 渲染线程与 JS 线程使互斥的。所以 js 脚本执行和浏览器布局、绘制不能同时执行。 在 60Hz，也就是美 16.6ms 内，要完成以">
<meta name="keywords" content="React">
<meta property="og:type" content="article">
<meta property="og:title" content="React原理">
<meta property="og:url" content="https://github.com/wangqinyong1994/blog/2020/11/29/react原理/index.html">
<meta property="og:site_name" content="王秦勇的博客">
<meta property="og:description" content="React中文官网 有两类场景会制约快速响应  当遇到大计算量的操作或设备性能不足使页面掉帧，导致卡顿。 发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。  概括为：CPU 瓶颈、IO 瓶颈 解决 CPU 瓶颈 js 可以操作 DOM，GUI 渲染线程与 JS 线程使互斥的。所以 js 脚本执行和浏览器布局、绘制不能同时执行。 在 60Hz，也就是美 16.6ms 内，要完成以">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkj899vmjmj310a0rsdmy.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gklinubpr1j30u014in20.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkmocaev2xj30gc12qtde.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkmoesqe5yj30gi190wjp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gklinubpr1j30u014in20.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkmpqdlkptj30vu0skwi0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkonwt9jkkj30zo0u07da.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkq4bun8c8j30vp0u04dc.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkzep06imaj311b0u07dm.jpg">
<meta property="og:updated_time" content="2021-01-23T08:55:05.560Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React原理">
<meta name="twitter:description" content="React中文官网 有两类场景会制约快速响应  当遇到大计算量的操作或设备性能不足使页面掉帧，导致卡顿。 发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。  概括为：CPU 瓶颈、IO 瓶颈 解决 CPU 瓶颈 js 可以操作 DOM，GUI 渲染线程与 JS 线程使互斥的。所以 js 脚本执行和浏览器布局、绘制不能同时执行。 在 60Hz，也就是美 16.6ms 内，要完成以">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkj899vmjmj310a0rsdmy.jpg">
  
    <link rel="alternate" href="/blog/atom.xml" title="王秦勇的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">王秦勇的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">记录一下</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/wangqinyong1994/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-react原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/11/29/react原理/" class="article-date">
  <time datetime="2020-11-29T07:05:48.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      React原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p><a href="https://react.docschina.org/docs/getting-started.html" target="_blank" rel="noopener">中文官网</a></p>
<p>有两类场景会制约快速响应</p>
<ol>
<li>当遇到大计算量的操作或设备性能不足使页面掉帧，导致卡顿。</li>
<li>发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</li>
</ol>
<p>概括为：CPU 瓶颈、IO 瓶颈</p>
<p><strong>解决 CPU 瓶颈</strong></p>
<p>js 可以操作 DOM，GUI 渲染线程与 JS 线程使互斥的。所以 js 脚本执行和浏览器布局、绘制不能同时执行。</p>
<p>在 60Hz，也就是美 16.6ms 内，要完成以下工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS脚本执行 -----  样式布局 ----- 样式绘制</span><br></pre></td></tr></table></figure>

<p>当 js 执行时间过长就无法完成后续操作，从而造成页面掉帧与卡顿。</p>
<p><strong>解决方案</strong>：在浏览器每一帧的时间中，预留一些时间给 js 线程，react 利用这部分时间更新组件。(react 源码中预留的初始时间为 5ms)</p>
<p><strong>当预留时间不够时</strong>，react 将线程控制权交还给浏览器，使其有时间渲染 UI，react 则等待下一帧时间到来继续被中断的工作。</p>
<p><strong>这种将长任务分拆到每一帧中，像蚂蚁搬家一样一次执行一小段任务的操作，被称为<code>时间切片</code>(time slice)。</strong></p>
<p>结论：解决 CPU 瓶颈的关键是实现时间切片，而时间切片的关键是：将同步的更新变为可中断的异步更新。</p>
<p><strong>IO 的瓶颈</strong></p>
<p>网络延迟是前端开发者无法解决的，如何在网络延迟客观存在的情况下，减少对网络延迟的感知？</p>
<p><strong>解决方案</strong>: 将人机交互研究的结果整合到真实的 UI 中。</p>
<p>进入页面 loading 场景：当一小段时间足够短时，用户是无感知的。如果请求时间超过一个范围，再显示 loading 效果。</p>
<p>如果进入页面就显示 loading，即使一闪而过，用户也可以感知。为了优化体验：</p>
<p><code>React</code>实现了<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html" target="_blank" rel="noopener">Suspense (opens new window)</a>功能及配套的<code>hook</code>——<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue" target="_blank" rel="noopener">useDeferredValue</a>。。。。。。。</p>
<h2 id="老-React-架构"><a href="#老-React-架构" class="headerlink" title="老 React 架构"></a>老 React 架构</h2><p>V15</p>
<h3 id="ReactV15-架构"><a href="#ReactV15-架构" class="headerlink" title="ReactV15 架构"></a>ReactV15 架构</h3><p>分为两层：</p>
<ul>
<li>Reconciler(协调器) —– 负责找出变化的组件</li>
<li>Renderer(渲染器) —– 负责将变化的组件渲染到页面上</li>
</ul>
<h3 id="Reconciler-协调器"><a href="#Reconciler-协调器" class="headerlink" title="Reconciler(协调器)"></a>Reconciler(协调器)</h3><p>触发更新方式：<code>this.setState</code> <code>this.forceUpdate</code> <code>ReactDOM.render</code></p>
<p>每当更新发生时， Reconciler 会有如下动作：</p>
<ol>
<li>调用函数组件或类组件的<code>render</code>，将返回的 JSX 转换成 VDOM</li>
<li>将 VDOM 与上次更新时的 VDOM 对比</li>
<li>通过对比找出本次更新中变化的 VDOM</li>
<li>通知 Renderer 将变化的 VDOM 渲染到页面上</li>
</ol>
<h3 id="Renderer-渲染器"><a href="#Renderer-渲染器" class="headerlink" title="Renderer(渲染器)"></a>Renderer(渲染器)</h3><p>浏览器端的渲染 Renderer—–ReactDOM</p>
<p>因为 react 支持跨平台，因此有别的 Renderer</p>
<ul>
<li>ReactNative 渲染器：渲染 App 原生组件</li>
<li>ReactTest 渲染器：渲染出纯 js 对象用于测试</li>
<li>ReactArt 渲染器：渲染到 Canvas，SVG 或 VML</li>
</ul>
<p>每次更新发生时，Renderer 接到 Reconciler 通知，将变化的组件渲染到当前宿主环境。</p>
<h3 id="存在的缺点"><a href="#存在的缺点" class="headerlink" title="存在的缺点"></a>存在的缺点</h3><p>Reconciler 中，<code>mount</code>的组件会调用<code>mountComponent</code>，<code>update</code>的组件会调用<code>updateComponent</code>。这两个方法都会递归更新子组件。</p>
<h4 id="递归更新的缺点"><a href="#递归更新的缺点" class="headerlink" title="递归更新的缺点"></a>递归更新的缺点</h4><p>由于递归执行，所以一旦开始，中途就无法中断，当层级很深，超过 16ms 用户交互就会卡顿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reconciler -&gt; Renderer -&gt; 页面更新变化 -&gt; Reconciler -&gt; Renderer -&gt;...</span><br></pre></td></tr></table></figure>

<h2 id="新-React-架构-V16"><a href="#新-React-架构-V16" class="headerlink" title="新 React 架构 V16"></a>新 React 架构 V16</h2><p>v16 架构分三层</p>
<ul>
<li>Scheduler(调度器) —–调度任务优先级，高优任务优先进入 Reconciler</li>
<li>Reconciler(协调器) —– 负责找出变化的组件</li>
<li>Renderer(渲染器) —– 负责将变化的组件渲染到页面上</li>
</ul>
<h3 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler(调度器)"></a>Scheduler(调度器)</h3><p>既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p>
<p><code>requestIdleCallback</code></p>
<p>react 放弃使用:</p>
<ul>
<li>浏览器兼容性问题</li>
<li>触发频率不稳定，受很多因素影响。</li>
</ul>
<p>然后 react 就自我实现了<code>requestIdleCallback</code>的 polyfill，就是 Scheduler。除了空闲时触发回调的功能，Scheduler 还提供了多种调度优先级任务设置。</p>
<p><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/README.md">Scheduler</a></p>
<h3 id="Reconciler-协调器-1"><a href="#Reconciler-协调器-1" class="headerlink" title="Reconciler(协调器)"></a>Reconciler(协调器)</h3><p>React15 时递归处理。16 就变成可中断的循环过程了。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function workLoopConcurrent() &#123;</span><br><span class="line">	while(workInProgress !== null &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">		workInProgress = performUnitOfWork(workInProgress);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React16 解决中断更新时 DOM 渲染不完全的问题？</p>
<p>Reconciler 与 Renderer 不再交替工作，当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的 VDOM 打上代表增删更新的标记。</p>
<p><strong>整个 Scheduler 与 Reconciler 的工作都在内存中进行，只有当所有组件都完成 Reconciler 的工作，才会统一交给 Renderer</strong></p>
<h3 id="Renderer-渲染器-1"><a href="#Renderer-渲染器-1" class="headerlink" title="Renderer(渲染器)"></a>Renderer(渲染器)</h3><p>如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkj899vmjmj310a0rsdmy.jpg" alt="如图"></p>
<p><code>Reconciler(协调器)</code> 内部采用了<code>fiber</code>架构</p>
<h2 id="React-V17"><a href="#React-V17" class="headerlink" title="React V17"></a>React V17</h2><h2 id="Fiber-架构"><a href="#Fiber-架构" class="headerlink" title="Fiber 架构"></a>Fiber 架构</h2><p>React Fiber 可以理解为：React 内部实现的一套状态更新机制。<strong>支持任务不同优先级，可中断与恢复，并且恢复后可以服用之前的中间状态</strong>。</p>
<p>其中每任务更新单元为 React Element 对应的 Fiber 节点。</p>
<h3 id="Fiber-含义"><a href="#Fiber-含义" class="headerlink" title="Fiber 含义"></a>Fiber 含义</h3><ol>
<li>V15 的 Reconciler 采用递归的方式进行，数据保存在递归调用栈中，因此被称为 stack Reconciler；V16 的 Reconciler 基于 Fiber 节点实现，被称为 Fiber Reconciler。</li>
<li>作为静态的数据结构来说，每个 Fiber 节点对应一个 React Ele，保存了该组件的类型、对应的 DOM 节点等信息。</li>
<li>作为动态工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态，要执行的工作。</li>
</ol>
<h3 id="Fiber-结构"><a href="#Fiber-结构" class="headerlink" title="Fiber 结构"></a>Fiber 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function FiberNode(</span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  pendingProps: mixed,</span><br><span class="line">  key: null | string,</span><br><span class="line">  mode: TypeOfMode</span><br><span class="line">) &#123;</span><br><span class="line">  // 作为静态数据结构的属性</span><br><span class="line">  // Fiber对应组件的类型 FC/Class/Host</span><br><span class="line">  // HostComponent指原生的HTML标签</span><br><span class="line">  this.tag = tag;</span><br><span class="line">  this.key = key;</span><br><span class="line">  // 大部分同type，某些情况不同，比如FC使用React.memo包裹</span><br><span class="line">  this.elementType = null;</span><br><span class="line">  // 对于FC,指函数本身，对于ClassComponent,指class，对于HostCompoent，指DOM节点tagName</span><br><span class="line">  this.type = null;</span><br><span class="line">  // Fiber对应的真实DOM节点</span><br><span class="line">  this.stateNode = null;</span><br><span class="line"></span><br><span class="line">  //用于连接其他Fiber节点形成Fiber树</span><br><span class="line">  this.return = null;</span><br><span class="line">  this.child = null;</span><br><span class="line">  this.sibling = null;</span><br><span class="line">  this.index = 0;</span><br><span class="line">  this.ref = null;</span><br><span class="line"></span><br><span class="line">  // 作为动态的工作单元属性</span><br><span class="line">  // 保存本次更新造成的状态改变相关信息</span><br><span class="line">  this.pendingProps = pendingProps;</span><br><span class="line">  this.memoizedProps = null;</span><br><span class="line">  this.updateQueue = null;</span><br><span class="line">  this.memoizedState = null;</span><br><span class="line">  this.dependencies = null;</span><br><span class="line">  this.mode = mode;</span><br><span class="line">  // 保存本次更新会造成的DOM操作</span><br><span class="line">  this.effectTag = NoEffect;</span><br><span class="line">  this.nextEffect = null;</span><br><span class="line">  this.firstEffect = null;</span><br><span class="line">  this.lastEffect = null;</span><br><span class="line"></span><br><span class="line">  // 调度优先级相关</span><br><span class="line">  this.lanes = NoLanes;</span><br><span class="line">  this.childLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  // 指向该fiber在另一次更新时对应的fiber</span><br><span class="line">  this.alternate = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 每个Fiber节点有个对应的React ele， 多个Fiber节点如何形成树，靠这几个属性</span><br><span class="line"></span><br><span class="line">// 指向父级Fiber节点</span><br><span class="line">this.return = null;</span><br><span class="line">// 指向子Fiber节点</span><br><span class="line">this.child = null;</span><br><span class="line">// 指向右边第一个兄弟Fiber节点</span><br><span class="line">this.sibling = null;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gklinubpr1j30u014in20.jpg" alt="例子"></p>
<h3 id="Fiber-工作原理"><a href="#Fiber-工作原理" class="headerlink" title="Fiber 工作原理"></a>Fiber 工作原理</h3><h4 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h4><p>类比 canvas 动画绘制，每一帧绘制前都会用<code>ctx.clearRect</code>清除上一帧画面。如果当前帧画面计算量较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。</p>
<p>为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了替换所需的计算时间，就不会出现画面闪烁问题。</p>
<p>这种在<strong>内存中构建并直接替换的技术叫双缓存</strong>。</p>
<p>React 使用双缓存来完成 Fiber 树的构建和替换，对应着 DOM 树的创建与更新。</p>
<h4 id="双缓存-Fiber-树"><a href="#双缓存-Fiber-树" class="headerlink" title="双缓存 Fiber 树"></a>双缓存 Fiber 树</h4><p>React 中最多同时存在两颗 Fiber 树：</p>
<ul>
<li>当前屏幕上显示内容对应的<code>current Fiber树</code></li>
<li>正在内存中构建的<code>workInProgress Fiber树</code></li>
</ul>
<p><code>current Fiber</code> : <code>current Fiber树</code>中的 Fiber 节点</p>
<p><code>workInProgress Fiber</code>: <code>workInProgress Fiber树</code>的 Fiber 节点</p>
<p>它们通过 alternate 属性连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFiber.alternate === workInProgressFiber;</span><br><span class="line">workInProgressFiber.alternate === currentFiber;</span><br></pre></td></tr></table></figure>

<p>React 应用的根节点通过 current 的指针在不同的 Fiber 树的 rootFiber 间切换来实现 Fiber 树的切换。</p>
<p>当 workInProgress Fiber 构建完成交给 Renderer 渲染在页面上后，应用根节点的 current 指向 workInprogress Fiber 树，此时 workInProgress Fiber 树就变为 current Fiber 树。</p>
<p>每次状态更新都会产生新的 workInProgress Fiber 树，<strong>通过 current 与 workInProgress 的替换，完成 DOM 更新</strong>。</p>
<p>自己：其实就是挂载时内存中构建树，然后当前树指向内存树，更新时，通过缓存的内存树完成类似 canvas 无缝切换的操作。。。</p>
<h2 id="React-源码文件结构"><a href="#React-源码文件结构" class="headerlink" title="React 源码文件结构"></a>React 源码文件结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根目录</span><br><span class="line">├── fixtures        # 包含一些给贡献者准备的小型 React 测试项目</span><br><span class="line">├── packages        # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）</span><br><span class="line">├── scripts         # 各种工具链的脚本，比如git、jest、eslint等</span><br></pre></td></tr></table></figure>

<h3 id="react-文件夹"><a href="#react-文件夹" class="headerlink" title="react 文件夹"></a>react 文件夹</h3><p>含所有全局 React API</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkmocaev2xj30gc12qtde.jpg" alt></p>
<p>以上这些全平台通用，不含 ReactDOM、ReactNative 等平台特定代码。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkmoesqe5yj30gi190wjp.jpg" alt></p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>调度器实现</p>
<h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>源码中其他模块公用的方法和全局变量</p>
<h3 id="Renderer-相关"><a href="#Renderer-相关" class="headerlink" title="Renderer 相关"></a>Renderer 相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- react-art- react-art</span><br><span class="line">- react-dom                 # 注意这同时是DOM和SSR（服务端渲染）的入口</span><br><span class="line">- react-native-renderer</span><br><span class="line">- react-noop-renderer       # 用于debug fiber（后面会介绍fiber）</span><br><span class="line">- react-test-renderer</span><br></pre></td></tr></table></figure>

<h3 id="试验性包文件夹"><a href="#试验性包文件夹" class="headerlink" title="试验性包文件夹"></a>试验性包文件夹</h3><p>React 将自己流程中的一部分抽离出来，形成可以独立使用的包，由于他们是试验性质，所以不被建议在生产环节使用。包括</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- react-server        # 创建自定义SSR流</span><br><span class="line">- react-client        # 创建自定义的流</span><br><span class="line">- react-fetch         # 用于数据请求</span><br><span class="line">- react-interactions  # 用于测试交互相关的内部特性，比如React的事件模型</span><br><span class="line">- react-reconciler    # Reconciler的实现，你可以用他构建自己的Renderer</span><br></pre></td></tr></table></figure>

<h3 id="辅助包文件夹"><a href="#辅助包文件夹" class="headerlink" title="辅助包文件夹"></a>辅助包文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- react-is       # 用于测试组件是否是某类型</span><br><span class="line">- react-client   # 创建自定义的流</span><br><span class="line">- react-fetch    # 用于数据请求</span><br><span class="line">- react-refresh  # “热重载”的React官方实现</span><br></pre></td></tr></table></figure>

<h3 id="react-reconciler-文件夹"><a href="#react-reconciler-文件夹" class="headerlink" title="react-reconciler 文件夹"></a>react-reconciler 文件夹</h3><p>重要！。。。一边对接 Scheduler，一边对接不同平台的 Renderer，构成了整个 React16 的架构体系。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>会被编译为 React.createElement</p>
<h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span> (<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 标记这是个React Element</span></span><br><span class="line">    $$<span class="keyword">typeof</span>: React_ELEMENT_TYPE,</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    props,</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>,</span><br><span class="line">    ref = <span class="literal">null</span>,</span><br><span class="line">    self = <span class="literal">null</span>,</span><br><span class="line">    source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将config处理后赋值给props</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 处理children,会被赋值给props.children</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理defaultProps</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createElement 返回了 ReactElement。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidElement</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> object === <span class="string">"object"</span> &amp;&amp;</span><br><span class="line">    object !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非null对象就是个合法的React Element。</span></span><br></pre></td></tr></table></figure>

<h3 id="React-Components"><a href="#React-Components" class="headerlink" title="React Components"></a>React Components</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AppClass <span class="keyword">instanceof</span> <span class="built_in">Function</span> === <span class="literal">true</span>;</span><br><span class="line">AppFunc <span class="keyword">instanceof</span> <span class="built_in">Function</span> === <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 无法通过引用类型区分ClassComponent和FunctionComponent</span></span><br><span class="line"><span class="comment">// React通过ClassComponent实例原型上的isReactComponent变量判断是否是ClassComponent</span></span><br><span class="line">ClassComponent.prototype.isReactComponent = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="JSX-与-Fiber-节点"><a href="#JSX-与-Fiber-节点" class="headerlink" title="JSX 与 Fiber 节点"></a>JSX 与 Fiber 节点</h3><p>jsx 是一种描述当前组件内容的数据结构，他不包含组件 schedule、reconcile、render 所需相关信息。</p>
<p>比如不包含：</p>
<ul>
<li>组件在更新中的优先级</li>
<li>组件的 state</li>
<li>组件被打上的用于 Renderer 的标记</li>
</ul>
<p>这些内容都包含在 Fiber 节点中。</p>
<p><strong>在组件 mount 时，Reconciler 根据 jsx 描述的组件内容生成组件对应的 Fiber 节点。</strong></p>
<p><strong>在 update 时，Reconciler 将 JSX 与 Fiber 节点保存的数据对比，生成组件对应的 Fiber 节点，并根据对比结果为 Fiber 节点打上标记。</strong></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h3><p>render 阶段开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>。这取决于本次更新时同步更新还是异步更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到区别在于<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，知道浏览器有空闲时间后再继续遍历。</p>
<p><code>workInProgress</code>代表当前已创建的<code>workInProgress fiber</code>。</p>
<p><code>performUnitWork</code>方法会创建下一个<code>Fiber</code>节点并赋值给<code>workInProgress</code>，并将<code>workInProgress</code>与已创建的<code>Fiber</code>节点连接起来构成<code>Fiber</code>树。</p>
<p>Fiber Reconciler 是从 Stack Reconciler 重构而来，通过遍历的方式实现可中断的递归，所以<code>performUnitWork</code>的工作可以分为两部分：递和归。</p>
<h4 id="递"><a href="#递" class="headerlink" title="递"></a>递</h4><p>首先从 rootFiber 开始向下深度优先遍历，为遍历到的每个 Fiber 节点调用<strong>beginWork</strong>方法。</p>
<p>该方法会<strong>根据传入的 Fiber 节点创建子 Fiber 节点，并将这两个 Fiber 节点连接起来</strong>。</p>
<p>当遍历到叶子节点(没有子组件的组件)时就会进入归阶段。</p>
<h4 id="归"><a href="#归" class="headerlink" title="归"></a>归</h4><p>归阶段会调用<strong>completeWork</strong>处理 Fiber 节点。</p>
<p>当某个 Fiber 节点执行完 completeWork，如果其存在兄弟 Fiber 节点(fiber.sibling !== null )，会进入其兄弟 Fiber 的递阶段。</p>
<p>如果不存在兄弟 FIber，会进入父级 Fiber 的归阶段。</p>
<p>递和归阶段交错执行，直到归到 rootFiber，至此，render 阶段的工作就结束了。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gklinubpr1j30u014in20.jpg" alt></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkmpqdlkptj30vu0skwi0.jpg" alt></p>
<h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><p>beginWork 的工作是，传入当前 Fiber 节点，创建子 Fiber 节点，具体实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// current: 当前组件对应的FIber节点在上一次更新时的Fiber节点，即workInProgress.alternate</span></span><br><span class="line"><span class="comment">// workInProgress: 当前组件对应的Fiber节点</span></span><br><span class="line"><span class="comment">// renderLanes: 优先级相关</span></span><br></pre></td></tr></table></figure>

<p>beginWork 工作分为两部分：</p>
<ul>
<li>update 时： 如果 current 存在，在满足一定条件时可以复用 current 节点，这样就能克隆 current.child 作为 workInProgress.child， 而不需新建 workInProgress.child</li>
<li>mount 时：除 fiberRootNode 以外, current === null。会根据 fiber.tag 不同，创建出不同类型的子 Fiber 节点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// update时，如果current存在可能的优化路径，可以复用current(即上一次更新的Fiber节点)</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> bailoutAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Update 时</strong></p>
<p>满足如下情况时，didReceiveUpdate === false(即可以直接复用前一次更新的子 Fiber，无需新建子 Fiber)</p>
<ol>
<li>oldProps === newProps &amp;&amp; workInProgress.type === current.type,即 props 与 fiber.type 不变</li>
<li>!includesSomeLane(renderLanes, updateLanes)，即当前 Fiber 节点优先级不够</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    oldProps !== newProps ||</span><br><span class="line">    hasLegacyContextChanged() ||</span><br><span class="line">    (__DEV__ ? workInProgress.type !== current.type : <span class="literal">false</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (</span><br><span class="line">      workInProgress.tag</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mount 时</strong></p>
<p>当不满足优化路径时，就要新建子 Fiber。对于我们常见组件类型，最终会进入 reconcileChildren 方法</p>
<p><strong>reconcileChildren</strong></p>
<p>是 Reconciler 模块的核心部分</p>
<ul>
<li>对 mount 的组件，会创建新的子 Fiber 节点</li>
<li>对于 update 的组件，会将当前组件与该组件在上次更新时对应的 Fiber 节点比较，diff，将比较的结果生成新的 Fiber 节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于mount的组件</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于update的组件</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.child,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论走哪个逻辑，最终都会生成新的子Fiber节点，并赋值给workInProgress.child，作为本次beginWork返回值，并作为下次performUnitOfWork执行时workInProgress的传参</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>mountChildFibers 与 reconcileChildFibers 方法逻辑基本一致，唯一区别是 reconcileChildFibers 会为生成的 Fiber 节点打上 effectTag 属性，mountChildFibers 不会。</p>
</blockquote>
<p><strong>effectTag</strong></p>
<p>render 阶段的工作在内存中进行，当工作结束后会通知 Renderer 想要执行的 DOM 操作，要执行 DOM 操作的具体类型就保存在 Fiber.effectTag 中。</p>
<p>通过二进制表示 effect，可以方便的使用位操作位 fiber.effectTag 赋值多少个 effect。</p>
<p>如果要通知 Renderer 将 FIber 节点对应的 DOM 节点插入页面中，需要满足两个条件：</p>
<ol>
<li>fiber.stateNode 存在，即 Fiber 节点中保存了对应的 DOM 节点</li>
<li>(Fiber.effectTag &amp; Placement) !== 0 ，即 Fiber 节点存在 Placement effectTag。</li>
</ol>
<p>fiber.stateNode 会在 completeWork 中创建</p>
<p>假设 mountChildFibers 也会赋值 effectTag,那么可以预见 mount 时整颗 Fiber 树所有节点都会有 Placement effectTag，那么 commit 阶段在执行 dom 操作时每个节点都会执行一次插入操作，这样大量 dom 操作是极低效的。解决：在 mount 时只有 rootFiber 会赋值 Placement effecttag, 在 commit 阶段只会执行一次插入操作。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkonwt9jkkj30zo0u07da.jpg" alt></p>
<h3 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwordRef:</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断 update 时还需要考虑 workInProgress.stateNode !== null ? （即<strong>该 Fiber 节点是否存在对应的 DOM 节点</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">  popHostContext(workInProgress);</span><br><span class="line">  <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">  <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// update时...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// mount时...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="update-时"><a href="#update-时" class="headerlink" title="update 时"></a>update 时</h4><p>当 update 时，FIber 节点已经存在对应 DOM 节点，所以不需要生成 DOM 节点，需要做的主要处理 props,如</p>
<ul>
<li>onClick、onChange 等回调函数住蹙额</li>
<li>处理 style prop</li>
<li>处理 DANGEROUSLY_SET_INNER_HTML prop</li>
<li>处理 children prop</li>
</ul>
<p>最主要的逻辑是调用 updateHostComponent 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">  zz(current, workInProgress, type, newProps, rootContainerInstance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在updateHostComponent内部，被处理完的props会被赋值给workInProgress.updateQueue,并最终会在commit阶段被渲染到页面上。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workInProgress.updateQueue = (updatePayload: <span class="built_in">any</span>);</span><br><span class="line"><span class="comment">// updatePayload为数组形式，它的奇数索引的值为变化的prop key，偶数索引的值为变化的prop value ？？？？updatePayload</span></span><br></pre></td></tr></table></figure>

<h4 id="mount-时"><a href="#mount-时" class="headerlink" title="mount 时"></a>mount 时</h4><p>mount 主要逻辑包含：</p>
<ul>
<li>为 Fiber 节点生成对应的 DOM 节点</li>
<li>将子孙 DOM 节点插入刚生成的 DOM 节点</li>
<li>与 update 逻辑中 updateHostComponent 类似的处理 props 过程</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line"><span class="comment">// 为fiber创建对应的DOM节点</span></span><br><span class="line"><span class="keyword">const</span> instance = createInstance(</span><br><span class="line">  type,</span><br><span class="line">  newProps,</span><br><span class="line">  rootContainerInstance,</span><br><span class="line">  currentHostContext,</span><br><span class="line">  workInProgress</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 将子孙DOM节点插入刚生成的DOM节点中</span></span><br><span class="line">appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// DOM节点赋值给fiber.stateNode</span></span><br><span class="line">workInProgress.stateNode = instance;</span><br><span class="line"><span class="comment">// 与update逻辑中的updateHostComponent类似的处理props的过程</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  finalizeInitialChildren(</span><br><span class="line">    instance,</span><br><span class="line">    type,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance,</span><br><span class="line">    currentHostContext</span><br><span class="line">  )</span><br><span class="line">) &#123;</span><br><span class="line">  markUpdate(workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commit 阶段如何通过一次插入 DOM 操作，将整颗 DOM 树插入页面？</p>
<p>completeWork 中的 appendAllChildren 方法，由于 completeWork 属于归阶段调用的函数，每次调用 appendAllChidren 时都会将已生成的子孙 DOM 节点插入当前生成的 DOM 节点下，因此当归到 rootFiber 时，已经有一个构建好的 DOM 树。</p>
<h4 id="effectList"><a href="#effectList" class="headerlink" title="effectList"></a>effectList</h4><p>问题：作为 dom 操作的依据，commit 阶段需要找到所有有 effectTag 的 fiber 节点，并依次执行 effectTag 对应的操作，那在 commit 阶段再遍历一次 FIber 树寻找 effectTag !== null 的 FIber 节点？</p>
<p>为解决这种低效的问题，在 completeWork 的上层函数 completeUnitOfWork 中，每个执行完 completeWork 且存在 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。</p>
<p>effectList 中第一个 Fiber 节点保存在 fiber.firstEffect，最后一个元素保存在 fiber.lastEffect。</p>
<p>类似 appendAllChildren,归阶段所有的 effectTag 的 Fiber 节点都会被追加在 effectList 中，最终形成一条以 rootFiber.firstEffect 为起点的单向链表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                       nextEffect         nextEffect</span><br><span class="line">rootFiber.firstEffect -----------&gt; fiber -----------&gt; fiber</span><br></pre></td></tr></table></figure>

<p>这样在 commit 阶段只需要遍历 effectList 就能执行所有 effect。</p>
<p>1 次归就存好链表再赋值。。。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkq4bun8c8j30vp0u04dc.jpg" alt></p>
<h3 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h3><p>commitRoot 方法是 commit 阶段工作的起点。fiberRootNode 会作为传参。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitRoot(root);</span><br></pre></td></tr></table></figure>

<p>在 rootFiber.firstEffect 上保存了一条需要执行副作用的 Fiber 节点的单向链表 effectList，这些 Fiber 节点的 updateQueue 中保存了变化的 props。</p>
<p>这些副作用对应的 DOM 操作在 commit 阶段执行。</p>
<p>除此之外，一些生命周期钩子、hook 需要在 commit 阶段执行。</p>
<p>commit 阶段主要工作(也就是 Renderer 的工作流程)分三部：</p>
<ul>
<li>Before mutation 阶段(执行 DOM 操作前)</li>
<li>mutation 阶段(执行 DOM 操作)</li>
<li>layout 阶段(执行 DOM 操作前后)</li>
</ul>
<h4 id="before-mutation-之前"><a href="#before-mutation-之前" class="headerlink" title="before mutation 之前"></a>before mutation 之前</h4><p>commitRootImpl 方法中直到第一句<code>if(firstEffect !== null)</code>之前属于 before mutation 之前</p>
<p>大体工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 触发useEffect回调与其他同步任务，由于这些任务可能触发新渲染，所以要一直遍历直到没有任务</span></span><br><span class="line">  flushPassiveEffects();</span><br><span class="line">&#125; <span class="keyword">while</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// root指 fiberRootNode</span></span><br><span class="line"><span class="comment">// root.finishedWork指当前应用的rootFiber</span></span><br><span class="line"><span class="keyword">const</span> finishedWork = root.finishedWork;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡是变量名带lane的都是优先级相关</span></span><br><span class="line"><span class="keyword">const</span> lanes = root.finishedLanes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (finishedWork === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">root.finishedLanes = NoLanes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置Scheduler绑定的回调函数</span></span><br><span class="line">root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">root.callbackId = NoLanes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置优先级相关变量</span></span><br><span class="line">markRootFinished(root, remainingLanes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除已完成的discrete updates 如：用户鼠标点击触发的更新</span></span><br><span class="line"><span class="keyword">if</span> (rootsWithPendingDiscreateUpdates !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !hasDiscreateLanes(remainingLanes) &amp;&amp;</span><br><span class="line">    rootsWithPendingDiscreateUpdates.has(root)</span><br><span class="line">  ) &#123;</span><br><span class="line">    rootsWithPendingDiscreateUpdates.delete(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置全局变量</span></span><br><span class="line"><span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgress = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将effectList赋值给firstEffect</span></span><br><span class="line"><span class="comment">// 由于每个fiber的effectList只包含他的子孙节点，所以根节点如果有effectTag则不会被包含进来，所以这里将有effectTag的根节点插入到effectList尾部，这样才能保证有effect的fiber都在effectList中</span></span><br><span class="line"><span class="keyword">let</span> firstEffect;</span><br><span class="line"><span class="keyword">if</span> (finishedWork.effectTag &gt; PerformedWork) &#123;</span><br><span class="line">  <span class="keyword">if</span> (finishedWork.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    finishedWork.lastEffect.nextEffect = finishedWork;</span><br><span class="line">    firstEffect = finishedWork.firstEffect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    firstEffect = finishedWork;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 根节点没有effectTag</span></span><br><span class="line">  firstEffect = finishedWork.firstEffect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="layout-之后"><a href="#layout-之后" class="headerlink" title="layout 之后"></a>layout 之后</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span><br><span class="line"></span><br><span class="line"><span class="comment">// useEffect相关</span></span><br><span class="line"><span class="keyword">if</span> (rootDidHavePassiveEffects) &#123;</span><br><span class="line">  rootDidHavePassiveEffects = <span class="literal">false</span>;</span><br><span class="line">  rootWithPendingPassiveEffects = root;</span><br><span class="line">  pengdingPassiveEffectLanes = lanes;</span><br><span class="line">  pendingPassiveEffectsRenderProprity = renderPriorityLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能优化相关</span></span><br><span class="line"><span class="keyword">if</span> (remainingLanes !== NoLanes) &#123;</span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能优化相关</span></span><br><span class="line"><span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!rootDidHavePassiveEffects) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测无限循环的同步任务</span></span><br><span class="line"><span class="keyword">if</span> (remainingLanes === SyncLane) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在离开commitRoot函数前调用，触发一次新的调度，确保任何附加的任务被调度</span></span><br><span class="line">ensureRootIsScheduled(root, now());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行同步任务，这样同步任务不需要等到下次事件循环再执行，比如componentDidMount中执行setState创建的更新会在这里被同步执行</span></span><br><span class="line">flushSyncCallbackQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>主要包括三点：</p>
<ol>
<li>useEffect 相关处理</li>
<li>性能追踪相关</li>
<li>在 commit 阶段会触发一些生命周期钩子</li>
</ol>
<h4 id="before-mutation-阶段"><a href="#before-mutation-阶段" class="headerlink" title="before mutation 阶段"></a>before mutation 阶段</h4><p>该阶段代码很短，整个过程就是遍历 effectList 并调用 commitBeforeMutationEffects 函数处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存之前的优先级，以同步优先级执行，执行完毕之后恢复之前优先级</span></span><br><span class="line"><span class="keyword">const</span> previousLanePriority = getCurrentUpdateLanePriority();</span><br><span class="line">setCuurrentUpdateLanePriority(SyncLanePriority);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前上下文标记为CommitContext，作为commit阶段的标志</span></span><br><span class="line"><span class="keyword">const</span> prevExectionContext = executionContext;</span><br><span class="line">executionContext |= CommitContext; <span class="comment">// |= 按位或</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理focus状态</span></span><br><span class="line">focusedInstanceHandle = prepareForCommit(root.containerInfo);</span><br><span class="line">shouldFireAfterActiveInstaceBlur = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// beforeMutation阶段的主函数</span></span><br><span class="line">commitBeforeMutationEffects(finishedWork);</span><br><span class="line"></span><br><span class="line">focusedInstanceHandle = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h5 id="commitBeforeMutationEffects"><a href="#commitBeforeMutationEffects" class="headerlink" title="commitBeforeMutationEffects"></a>commitBeforeMutationEffects</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ...focus blur相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="comment">// 调用getSnapshotBeforeUpdate</span></span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; Snapshot) !== NoEffect) &#123;</span><br><span class="line">      commitBeforeMutationEffectOnFiber(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度useEffect</span></span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">        rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">        scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">          flushPassiveEffects();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体分三部：</p>
<ol>
<li>处理 DOM 节点渲染/删除后的 autoFocus、blur 逻辑</li>
<li>调用 getSnapshotBeforeUpdate 生命周期钩子</li>
<li>调度 useEffect</li>
</ol>
<h5 id="调用-getSnapshotBeforeUpdate"><a href="#调用-getSnapshotBeforeUpdate" class="headerlink" title="调用 getSnapshotBeforeUpdate"></a>调用 getSnapshotBeforeUpdate</h5><p>commitBeforeMutationEffectOnFiber 是 commitBeforeMutationLifeCycles 的别名</p>
<p>在该方法内会调用 getSnapshotBeforeUpdate</p>
<p>UNSAFE_原因：V15 -&gt; V16，render 阶段(componentWillxxxx)可能触发多次</p>
<p><strong>为此，用 getSnapshotBeforeUpdate 替代。可以看见 getSnapshotBeforeUpdate 是在 commit 阶段内的 before mutation 阶段调用，由于 commit 阶段是同步的，所以不会遇到多次调用问题。</strong></p>
<h5 id="调度-useEffect"><a href="#调度-useEffect" class="headerlink" title="调度 useEffect"></a>调度 useEffect</h5><p>scheduleCallback 是由 Scheduler 模块提供，用于以某个优先级异步调度一个回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度useEffect</span></span><br><span class="line"><span class="keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">    rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">    scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 触发useEffect</span></span><br><span class="line">      flushPassiveEffects();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="如何异步调度"><a href="#如何异步调度" class="headerlink" title="如何异步调度"></a>如何异步调度</h5><p>在 flushPassiveEffects 方法内部会从全局变量 rootWithPendingPassiveEffects 获取 effectList。</p>
<p>effectList 中保存了需要执行副作用的 Fiber 节点，其中副作用包括</p>
<ul>
<li>插入 DOM 节点(Placement)</li>
<li>更新 DOM 节点(Update)</li>
<li>删除 DOM 节点(Deletion)</li>
</ul>
<p>除此外，当一个 FC 含有 useEffect 或者 useLayoutEffect，他对应的 Fiber 节点也会被赋值 effectTag。</p>
<p>在 flushPassiveEffects 方法内部会遍历 rootDoesHavePassiveEffects 执行 effect 回调函数。</p>
<p>此时如果直接执， rootDoesHavePassiveEffects === null</p>
<p>rootDoesHavePassiveEffects 会在何时赋值？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span><br><span class="line"><span class="keyword">if</span> (rootDoesHavePassiveEffects) &#123;</span><br><span class="line">  rootDoesHavePassiveEffects = <span class="literal">false</span>;</span><br><span class="line">  rootWithPengdingPassiveEffects = root;</span><br><span class="line">  pendingPassiveEffectsLanes = lanes;</span><br><span class="line">  pendingPassiveEffectsRenderPriority = renderPriorityLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以整个 useEffect 异步调用分三步：</p>
<ol>
<li>Before mutation 阶段在 scheduleCallback 中调度 flushPassiveEffects</li>
<li>layout 阶段之后将 effectList 赋值给 rootWithPengdingPassiveEffects</li>
<li>scheduleCallback 触发 flushPassiveEffects，flushPassiveEffects 内部遍历 rootWithPengdingPassiveEffects</li>
</ol>
<h5 id="为何异步调用"><a href="#为何异步调用" class="headerlink" title="为何异步调用"></a>为何异步调用</h5><blockquote>
<p>与 componentDIdMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用，这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>
</blockquote>
<p>主要是防止同步执行时阻塞浏览器渲染。</p>
<h3 id="mutation-阶段"><a href="#mutation-阶段" class="headerlink" title="mutation 阶段"></a>mutation 阶段</h3><p>DOM 操作</p>
<p>mutation 阶段也是遍历 effectList，执行函数，这里执行的是 commitMutationEffects。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nextEffect = firstEffect;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commitMutationEffects(root, renderPriorityLevel);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    invariant(next !== <span class="literal">null</span>, <span class="string">"Should be working on an effect."</span>);</span><br><span class="line">    captureCommitPhaseError(nextEffect, error);</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="commitMutationEffects"><a href="#commitMutationEffects" class="headerlink" title="commitMutationEffects"></a>commitMutationEffects</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params">root: FiberRoot, renderPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历effectList</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="comment">// 根据ContentReset effectTag重置文字节点</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; ContentReset) &#123;</span><br><span class="line">      commitResetTextContent(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新Ref</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        commitDetachRef(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据effectTag分别处理</span></span><br><span class="line">    <span class="keyword">const</span> primaryEffectTag =</span><br><span class="line">      effectTag &amp; (Placement | Update | Deletion | Hydrating);</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="comment">// 插入dom</span></span><br><span class="line">      <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入dom并更新dom</span></span><br><span class="line">      <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// SSR</span></span><br><span class="line">      <span class="keyword">case</span> Hydrating: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;= ~Hydrating;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// SSR</span></span><br><span class="line">      <span class="keyword">case</span> HydratingAndUpdate: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;= ~Hydrating;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新dom</span></span><br><span class="line">      <span class="keyword">case</span> Update: &#123;</span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除dom</span></span><br><span class="line">      <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">        commitDeletion(root, nextEffect, renderPriorityLevel);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commitMutationEffects 会遍历 effectList，对每个 Fiber 节点执行如下操作:</p>
<ul>
<li>根据 ContentReset effectTag 重置文字节点</li>
<li>更新 Ref</li>
<li>根据 effectTag 分别处理，其中 effectTag 包括(Placement | Update | Deletion | Hydrating)</li>
</ul>
<h4 id="Placement-effect"><a href="#Placement-effect" class="headerlink" title="Placement effect"></a>Placement effect</h4><p>当 FIber 节点含有 Placement effectTag，意味着 Fiber 节点对应的 DOM 节点需要插入到页面中。</p>
<p>调用的方法为 commitPlacement</p>
<p>分三步：</p>
<ol>
<li>获取父级 dom 节点，其中 finishedWork 为传入的 Fiber 节点</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);</span><br><span class="line"><span class="comment">// 父级dom节点</span></span><br><span class="line"><span class="keyword">const</span> parentStateNode = parentFiber.stateNode;</span><br></pre></td></tr></table></figure>

<p>2.获取 Fiber 节点的 dom 兄弟节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据 dom 兄弟节点是否存在决定调用 parentNode.insertBefore 或 parentNode.appendChild 执行 dom 插入操作。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentStateNode是否是rootFiber</span></span><br><span class="line"><span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">  insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getHostSibling 这步操作很耗时，当在同一个父级 Fiber 节点下一次执行多个插入操作，getHostSibling 算法复杂度为指数级。。。。</p>
<h4 id="Update-effect"><a href="#Update-effect" class="headerlink" title="Update effect"></a>Update effect</h4><p>当 Fiber 节点含有 update effecting，意味该 FIber 节点需要更新，调用的方法为 commitWork，会根据 FIber.tag 分别处理。</p>
<h4 id="FC-mutation"><a href="#FC-mutation" class="headerlink" title="FC mutation"></a>FC mutation</h4><p>当 tag 类型为 FC,会调用 commitHookEffectListUnmount。该方法会遍历 effectList，执行所有 useLayoutEffect hook 的销毁函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...副作用逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...销毁函数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="HostComponent-mutation"><a href="#HostComponent-mutation" class="headerlink" title="HostComponent mutation"></a>HostComponent mutation</h4><p>当 tag 类型为 HostComponent,会调用 commitUpdate。</p>
<p>最终会在 updateDOMProperties 中将 render 阶段 completeWork 中为 fiber 节点赋值的 updateQueue 对应的内容渲染在页面上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; updatePayload.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> propKey = updatePayload[i];</span><br><span class="line">  <span class="keyword">const</span> propValue = updatePayload[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">    setValueForStyles(domElement, propValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">    setInnerHTML(domElement, propValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">    setTextContext(domElement, propValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理props</span></span><br><span class="line">    setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Deletion-effect"><a href="#Deletion-effect" class="headerlink" title="Deletion effect"></a>Deletion effect</h4><p>节点含有 Deletion effectTag,意味着该 fiber 节点对应的 dom 节点需要从页面中删除，调用方法为 commitDeletion。</p>
<p>该方法会执行如下操作：</p>
<ol>
<li>递归调用 Fiber 节点及其子孙 Fiber 节点中 fiber.tag 为 ClassComponent 的 componentWillUnmount 生命周期钩子，从页面中一次 fiber 节点对应的 dom 节点。</li>
<li>解绑 ref</li>
<li>调度 useEffect 的销毁函数</li>
</ol>
<p>mutation 阶段会遍历 effectList，依次执行 commitMutationEffects。该方法主要工作为根据 effectTag 调用不同的处理函数处理 FIber。</p>
<h3 id="layout-阶段"><a href="#layout-阶段" class="headerlink" title="layout 阶段"></a>layout 阶段</h3><p>该阶段的代码都是在 DOM 渲染完成后执行的。</p>
<p>该阶段触发的生命周期钩子和 hook 可以之际访问到已经改变后的 dom，即该阶段是可以参与 dom layout 的阶段。</p>
<p>与 before mutation 和 mutation 阶段一样，该阶段也是遍历 effectList，执行函数。</p>
<p>具体执行的函数是 commitLayoutEffects。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root.current = finishedWork;</span><br><span class="line"></span><br><span class="line">nextEffect = firstEffect;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commitLayoutEffects(root, lanes);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    invariant(nextEffect !== <span class="literal">null</span>, <span class="string">"should be working on an effect"</span>);</span><br><span class="line">    captureCommitPhaseError(nextEffect, error);</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line">nextEffect = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="commitLayoutEffects"><a href="#commitLayoutEffects" class="headerlink" title="commitLayoutEffects"></a>commitLayoutEffects</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects</span>(<span class="params">root: FiberRoot, commit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用生命周期钩子和hook</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitLayoutEffectOnFiber(root, current, nextEffect, commitedLanes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值ref</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      commitAttachRef(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做了两件事</p>
<ol>
<li>commitLayoutEffectOnFiber(调用生命周期钩子和 hook)</li>
<li>commitAttachRef(赋值 ref)</li>
</ol>
<h4 id="commitLayoutEffectOnFiber"><a href="#commitLayoutEffectOnFiber" class="headerlink" title="commitLayoutEffectOnFiber"></a>commitLayoutEffectOnFiber</h4><p>根据 fiber.tag 对不同类型的节点分别处理。</p>
<ul>
<li><p>对 ClassComponent，会通过 current === null 区分 mount 还是 update，调用 componentDidMount 或 componentDidUpdat。</p>
<p>触发状态更新的 this.setState 如果赋值了第二个参数回调函数，也会在此时调用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"xxxxx"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对 FC 及相关类型，会调用 useLayoutEffect hook 的回调函数，调度 useEffect 的销毁与回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关类型指特殊处理后的FC,如ForwardRef、React.memo包裹的FC</span></span><br><span class="line"><span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">  <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">  <span class="keyword">case</span> ForwardRef:</span><br><span class="line">  <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">  <span class="keyword">case</span> Block: &#123;</span><br><span class="line">    <span class="comment">// 执行useLayoutEffect的回调函数</span></span><br><span class="line">    commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">    <span class="comment">// 调度useEffect的销毁函数与回调函数</span></span><br><span class="line">    schedulePassiveeEffects(finishedWork);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useLayoutEffect 与 useEffect 区别：</p>
<p>​ useLayoutEffect<strong>从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的</strong>。 先销毁再同步更新</p>
<p>​ useEffect 则<strong>需要先调度，在 Layout 阶段完成后在异步执行</strong>。 先调度再异步执行</p>
</li>
<li><p>对 HostRoot，如果赋值了第三个参数回调函数，也会在此时调用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"), function () &#123;</span><br><span class="line">  console.log("mount");</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="commitAttachRef"><a href="#commitAttachRef" class="headerlink" title="commitAttachRef"></a>commitAttachRef</h4><p>commitLayoutEffects 做的第二件事是 commitAttachRef</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.ref;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取dom实例</span></span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> HostComponent:</span><br><span class="line">        instanceToUse = getPublicInstance(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果ref时函数形式，调用回调函数</span></span><br><span class="line">      ref(instanceToUse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是ref形式，赋值ref.current</span></span><br><span class="line">      ref.current = instanceToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="current-Fiber-树切换"><a href="#current-Fiber-树切换" class="headerlink" title="current Fiber 树切换"></a>current Fiber 树切换</h4><p>至此整个 layout 阶段结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.current = finishedWork;</span><br></pre></td></tr></table></figure>

<p>双缓存机制中,workInProgress Fiber 树在 commit 阶段完成渲染后会变为 current Fiber 树，这行代码的作用就是切换 fiberRootNode 指向的 current Fiber 树。</p>
<p>为啥这行代码在这？</p>
<p>componentWillUnmount 会在 mutation 阶段执行，此时 current Fiber 树还指向前一次更新的 Fiber 树，在生命周期钩子内获取的 DOM 还是更新前的。</p>
<p>componentDidMount 和 componentDidUpdate 会在 layout 阶段执行，此时 current Fiber 树已经指向更新后的 Fiber 树，在生命周期钩子内获取的 DOM 就是更新后的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><blockquote>
<p>一个 dom 节点在某一时刻最多会有 4 个节点和他相关。</p>
<ol>
<li>current FIber。如果该 dom 节点已在页面中，current fiber 代表该 dom 节点对应的 fiber 节点</li>
<li>workInProgress Fiber。如果该 dom 节点在本次更新中渲染到页面中，workInProgress Fiber 代表该 dom 节点对应的 fiber 节点。</li>
<li>dom 节点本身。</li>
<li>JSX 对象。ClassComponent 的 render 方法，或 FC 的调用结果。JSX 对象中包含描述 dom 节点的信息。</li>
</ol>
<p><strong>diff 本质是对比 1 和 4 生成 2.</strong></p>
</blockquote>
<h3 id="diff-瓶颈以及-react-的应对"><a href="#diff-瓶颈以及-react-的应对" class="headerlink" title="diff 瓶颈以及 react 的应对"></a>diff 瓶颈以及 react 的应对</h3><p>两棵树完全比对的算法复杂程度为 O(n^3)，其中 n 是树中元素的数量。</p>
<p>为降低算法复杂度，react 的 diff 会预设 3 个限制：</p>
<ol>
<li>只对同级元素进行 diff。如果一个 dom 节点在前后两次更新中跨越了层级，那么 react 不会尝试复用它。（只同层比，跨级不比较）</li>
<li>两个不同类型的元素会产生不同的树。如果元素由 div 变为 p，react 会销毁 div 及其子孙节点，并新建 p 及其子孙节点。（元素不同树不同，只有销毁与新增操作）</li>
<li>可通过 key 来暗示子元素在不同的渲染下能保持稳定。</li>
</ol>
<h3 id="diff-实现"><a href="#diff-实现" class="headerlink" title="diff 实现"></a>diff 实现</h3><p>从 diff 入口函数 reconcileChildFibers 出发，该函数会根据 newChild 类型调用不同的处理函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据newChild类型选择不同diff函数处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  newChild: any</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">"object"</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">      <span class="comment">// 调用reconcilesSingleElement处理</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">"string"</span> || <span class="keyword">typeof</span> newChild === <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用reconcileSingleTextNode处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">    <span class="comment">// 调用reconcileChildrenArray处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以上都没有命中,删除节点</span></span><br><span class="line">  <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将同级的节点数量将 diff 分为两类：</p>
<ol>
<li>当 newChild 类型为 object 、number、string，代表统计只有一个节点</li>
<li>当 newChild 类型为 Array，统计有多个节点。</li>
</ol>
<h4 id="单节点-diff"><a href="#单节点-diff" class="headerlink" title="单节点 diff"></a>单节点 diff</h4><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkzep06imaj311b0u07dm.jpg" alt></p>
<p>判断 dom 节点是否可以复用的实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSiingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (child.tag) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.elementType === element.type) &#123;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// type不同会跳出循环</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 代码执行到这里代表key相同但是type不同</span></span><br><span class="line">      <span class="comment">// 将该fiber及其兄弟fiber标记为删除</span></span><br><span class="line">      deleteRemainingChildren(returnFIber, child);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// key不同，将该fiber标记为删除</span></span><br><span class="line">      deleteChild(returnFiber, child);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建新Fiber并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key 相同? =&gt; type 相同? =&gt; 都相同 dom 节点才能复用。</p>
<h4 id="多节点-diff"><a href="#多节点-diff" class="headerlink" title="多节点 diff"></a>多节点 diff</h4><p>日常开发中，<strong>更新组件发生的频率较新增和删除更高</strong>，所以 diff 会优先判断当前节点是否是属于更新。</p>
<blockquote>
<p>虽然更新的 jsx 对象 newChildren 为数组形式，但是和 newChildren 中每个组件进行比较的是 current fiber，同级的 Fiber 节点是由 sibling 指针链接形成的单链表，即不支持双指针遍历。</p>
<p>因此无法使用双指针优化。</p>
</blockquote>
<p>基于以上，diff 的整体逻辑会经历两轮遍历。</p>
<p>第一轮遍历：处理更新的节点。</p>
<p>第二轮遍历：处理剩下的不属于更新的节点。</p>
<h5 id="第一轮遍历"><a href="#第一轮遍历" class="headerlink" title="第一轮遍历"></a>第一轮遍历</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. newChildren[i]与oldFiber比较，判断dom节点是否能复用</span><br><span class="line">2. 可服用，i++，继续比较newChildren[i]与oldFiber.slibling，可以复用则继续遍历</span><br><span class="line">3. 不可复用两种情况：1)key不同导致，立即跳出整个遍历，第一轮遍历结束 2)key同type不同，将oldFiber标记为DELETION，并继续遍历。</span><br><span class="line">4. 如果newChildren遍历完或oldFiber遍历完，跳出遍历，第一轮遍历结束</span><br></pre></td></tr></table></figure>

<p>带第一轮遍历结果进行第二轮遍历。</p>
<h5 id="第二轮遍历"><a href="#第二轮遍历" class="headerlink" title="第二轮遍历"></a>第二轮遍历</h5><p>newChildren（1）、oldFiber（2）</p>
<p>（1）（2）同时遍历完：只需在第一轮遍历进行组件更新。此时 diff 结束</p>
<p>（1）没完（2）完：已有 dom 节点都复用了，这时还有新加入的节点，意味本季更新有新节点插入，我们只需遍历剩下 newChildren 为生成的 workInProgress fiber 依次标记 placement</p>
<p>（1）完（2）没完：意味本次更新比之前的节点数量少，有节点被删除，所以需要遍历剩下 oldFiber，依次标记 Deletion</p>
<p>（1）（2）同时没完：意味有节点在这次更新中改变了位置</p>
<h5 id="处理移动的节点"><a href="#处理移动的节点" class="headerlink" title="处理移动的节点"></a>处理移动的节点</h5><p>需要用 key。</p>
<p>为快速找到 key 对应的 oldFiber，要将还未处理的 oldFiber 存入以 key 为 key，oldFiber 为 value 的 Map 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br></pre></td></tr></table></figure>

<p>接下来遍历剩余的 newChildren，通过 newChildren[i].key 就能在 existingChilren 中找到 key 相同的 oldFiber</p>
<h5 id="标记节点是否移动"><a href="#标记节点是否移动" class="headerlink" title="标记节点是否移动"></a>标记节点是否移动</h5><p>参照物：最后一个可复用的节点在 oldFIber 的位置索引。</p>
<p>???</p>
<p>节点是按 newChildren 顺序排列，在遍历 newChildren 过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个，即一定在 lastPlaceIndex 对应的可复用的节点在本次更新中位置的后面。</p>
<p>那我们只需比较遍历到的可复用节点在上次更新时是否也在 lastPlaceIndex 对应的 oldFIber 后面，就能知道两次更新中这两个节点的相对位置有没有改变。</p>
<p>如果 oldIndex &lt; lastPlacedIndex，代表本次更新该节点需要向右移动。</p>
<p>lastPlacedIndex 初始为 0，每遍历一个可复用的节点，如果 oldIndex &gt;= lastPlacedIndex，则 lastPlacedIndex = oldIndex.</p>
<h3 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h3><h4 id="Update-结构"><a href="#Update-结构" class="headerlink" title="Update 结构"></a>Update 结构</h4><p>ClassComponent 与 HostRoot 共用同一种 Update 结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> update: Update&lt;*&gt; = &#123;</span><br><span class="line">  eventTime, <span class="comment">// 任务时间</span></span><br><span class="line">  lane, <span class="comment">// 优先级相关</span></span><br><span class="line">  suspenseConfig, <span class="comment">// Suspense相关</span></span><br><span class="line">  tag: UpdateState, <span class="comment">// 更新的类型 UpdateState ｜ ReplaceState | ForceUpdate | CaptureUpdate</span></span><br><span class="line">  payload: <span class="literal">null</span>, <span class="comment">// 更新挂载的数据</span></span><br><span class="line">  callback: <span class="literal">null</span>, <span class="comment">// 更新的回调函数</span></span><br><span class="line">  next: <span class="literal">null</span>, <span class="comment">// 与其他Update连接形成链表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 由createUpdate返回</span></span><br></pre></td></tr></table></figure>

<h4 id="UpdateQueue"><a href="#UpdateQueue" class="headerlink" title="UpdateQueue"></a>UpdateQueue</h4><p>有 3 种类型</p>
<p>ClassComponent 与 HostRoot 使用的 UpdateQueue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">  baseState: fiber.memoizedState, <span class="comment">// 本次更新前该fiber节点的state, Update基于该state计算更新后的state</span></span><br><span class="line">  firstBaseUpdate: <span class="literal">null</span>, <span class="comment">// 链表头</span></span><br><span class="line">  lastBaseUpdate: <span class="literal">null</span>, <span class="comment">// 链表尾</span></span><br><span class="line">  shared: &#123;</span><br><span class="line">    pending: <span class="literal">null</span>, <span class="comment">// 触发更新时，产生的Update会保存在shared.penging中形成单向环状链表</span></span><br><span class="line">  &#125;,</span><br><span class="line">  effects: <span class="literal">null</span>, <span class="comment">// 数组。保存update.callback !== null的Update</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>？？？</p>
<p><a href="https://react.iamkasong.com/state/priority.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">优先级</a></p>
<h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h3><h4 id="创建-fiber"><a href="#创建-fiber" class="headerlink" title="创建 fiber"></a>创建 fiber</h4><p>首次执行 ReactDOM.render 会创建 fiberRootNode 和 rootFiber。其中 fiberRootNode 是整个应用的根节点，rootFiber 是要渲染组件树的根节点。</p>
<p>这一步发生在调用 ReactDOM.render 后进入的 legacyRenderSubtreeIntoContainer 方法中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// container指ReactDOM.render的第二个参数</span></span><br><span class="line">root = container._reactRootContainer = legacyCreteRootFromDOMContainer(</span><br><span class="line">  container,</span><br><span class="line">  forceHydrate</span><br><span class="line">);</span><br><span class="line">fiberRoot = root._internalRoot;</span><br></pre></td></tr></table></figure>

<p>legacyCreteRootFromDOMContainer 方法内部会调用 createFiberRoot 方法完成 fiberRootNode 和 rootFiber 的创建以及关联。并初始化 updateQueue。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: RootTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrationCallbacks: null | SuspenseHydrationCallbacks</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建fiberRootNode</span></span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = (<span class="keyword">new</span> FiberRootNode(containerInfo, tag, hydrate): any);</span><br><span class="line">  <span class="comment">// 创建rootFiber</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">  <span class="comment">// 连接rootFiber与fiberRootNode</span></span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line">  <span class="comment">// 初始化updateQueue</span></span><br><span class="line">  initialzeUpdateQueue(uninitializedFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-update"><a href="#创建-update" class="headerlink" title="创建 update"></a>创建 update</h4><p>做好了组件的初始化工作，接下来就等待创建 Update 来开启一次更新。</p>
<p>这一步发生在 updateContainer 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent?: React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(eventTime, lane, suspenseConfig);</span><br><span class="line">  <span class="comment">// update.payload为需要挂载在根节点的组件</span></span><br><span class="line">  update.payload = &#123; element &#125;;</span><br><span class="line">  <span class="comment">// callback为ReactDOM.render的第三个参数</span></span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将生成的update加入updateQueue</span></span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  <span class="comment">// 调度更新</span></span><br><span class="line">  scheduleUpdateOnFiber(current, lane, eventTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程</p>
<p>创建各种 node 对象、创建更新对象、从 fiber 到 root、调度更新、diff 渲染(同步/异步)、提交更新</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">创建fiberRootNode、rootFiber、updateQueue（`legacyCreateRootFromDOMContainer`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">创建Update对象（`updateContainer`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">从fiber到root（`markUpdateLaneFromFiberToRoot`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">调度更新（`ensureRootIsScheduled`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）</span><br><span class="line"></span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"></span><br><span class="line">commit阶段（`commitRoot`）</span><br></pre></td></tr></table></figure>

<h3 id="this-setState"><a href="#this-setState" class="headerlink" title="this.setState"></a>this.setState</h3><h4 id="this-setState-1"><a href="#this-setState-1" class="headerlink" title="this.setState"></a>this.setState</h4><p>该方法会调用 this.updater.enqueueSetState 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !(</span><br><span class="line">      <span class="keyword">typeof</span> partialState === <span class="string">"object"</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> partialState === <span class="string">"function"</span> ||</span><br><span class="line">      partialState === <span class="literal">null</span></span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">"setState(...): takes an object of state variables to update or a function which returns an object of state variables."</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">"setState"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>enqueueSetState 方法中就是 从创建 update 到调度 update 的流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enqueueSetState(inst, payload, callback) &#123;</span><br><span class="line">  <span class="comment">// 通过组件实例获取对应fiber</span></span><br><span class="line">  <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">  <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">  <span class="keyword">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class="line">  <span class="comment">// 获取优先级</span></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber, suspenseConfig);</span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(eventTime, lane, suspenseConfig);</span><br><span class="line">  update.payload = payload;</span><br><span class="line">  <span class="comment">// 赋值回调函数</span></span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将update插入updateQueue</span></span><br><span class="line">  enqueueUpdate(fiber, update)</span><br><span class="line">  <span class="comment">// 调度update</span></span><br><span class="line">  scheduleUpdateOnFiiber(fiber, lane, eventTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="this-forceUpdate"><a href="#this-forceUpdate" class="headerlink" title="this.forceUpdate"></a>this.forceUpdate</h4><p>this.updater 上，除了 enqueueSetState 外，还存在 enqueueForceUpdate，当我们调用 this.forceUpdate 时会调用他。</p>
<p>除了<code>update.tag = ForceUpdate</code>，以及没有额外<code>payload</code>，其他逻辑与<code>this.setState</code>一致。。。</p>
<h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><h4 id="极简-hooks-实现"><a href="#极简-hooks-实现" class="headerlink" title="极简 hooks 实现"></a>极简 hooks 实现</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, updateNum] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;p onClick=&#123;() =&gt; updateNum((num) =&gt; num + 1)&#125;&gt;&#123;num&#125;&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可将工作分为两部：</p>
<ol>
<li>通过一些途径产生更新，更新会造成组件 render</li>
<li>组件 render 时 useState 返回 num 为更新后的结果</li>
</ol>
<p>步骤 1 分为 mount 和 update</p>
<ol>
<li>调用 ReactDOM.render 会产生 mount 的更新，更新内容为 useState 的 initialVal</li>
<li>点击 p 标签触发 updateNum 会产生一次 update 更新，更新内容为 num =&gt; num + 1</li>
</ol>
<h4 id="更新是啥"><a href="#更新是啥" class="headerlink" title="更新是啥"></a>更新是啥</h4><p>如上例子 更新就是如下数据结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> update = &#123;</span><br><span class="line">  <span class="comment">// 更新执行的函数</span></span><br><span class="line">  action,</span><br><span class="line">  <span class="comment">// 写同一个Hook的其他更新形成链表</span></span><br><span class="line">  next: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改写下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">return</span> &lt;p onClick=&#123;() =&gt; updateNum((num) =&gt; num + 1)&#125;&gt;&#123;num&#125;&lt;/p&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;p</span><br><span class="line">    onClick=&#123;() =&gt; &#123;</span><br><span class="line">      updateNum(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">1</span>);</span><br><span class="line">      updateNum(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">1</span>);</span><br><span class="line">      updateNum(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">1</span>);</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;num&#125;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<p>点 p 会产生 3 个 update</p>
<h4 id="update-数据结构"><a href="#update-数据结构" class="headerlink" title="update 数据结构"></a>update 数据结构</h4><p>q: 这些 update 如何组合在一起？</p>
<p>a: 他们会形成环状单向链表</p>
<p>调用 updateNum 实际调用的是 dispatchAction.bind(null, hook.queue)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>(<span class="params">queue, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建update</span></span><br><span class="line">  <span class="keyword">const</span> update = &#123;</span><br><span class="line">    action,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 环状单向链表操作</span></span><br><span class="line">  <span class="keyword">if</span> (queue.pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.next = next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.next = queue.pending.next;</span><br><span class="line">    queue.pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.pending = update;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟React开始调度更新</span></span><br><span class="line">  schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态如何保存"><a href="#状态如何保存" class="headerlink" title="状态如何保存"></a>状态如何保存</h4><p>q: ClassComponent 的实例可以存储数据，对于 FC，queue 存在哪呢？</p>
<p>a: FC 对应的 fiber 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App组件对应的fiber对象</span></span><br><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">  <span class="comment">// 保存该FC对应的Hooks链表</span></span><br><span class="line">  memoizedState: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向App函数</span></span><br><span class="line">  stateNode: App,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Hook-数据结构"><a href="#Hook-数据结构" class="headerlink" title="Hook 数据结构"></a>Hook 数据结构</h4><p>Hook 与 update 类似，通过链表连接，不过 hook 是无环的单向链表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hook = &#123;</span><br><span class="line">  <span class="comment">// 保存update的queue</span></span><br><span class="line">  queue: &#123;</span><br><span class="line">    pending: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 保存hook对应的state</span></span><br><span class="line">  memoizedState: initialState,</span><br><span class="line">  <span class="comment">// 与下一个hook连接形成单向无环链表</span></span><br><span class="line">  next: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="模拟-React-调度更新流程"><a href="#模拟-React-调度更新流程" class="headerlink" title="模拟 React 调度更新流程"></a>模拟 React 调度更新流程</h4><p>用 isMount 指代 mount 还是 update</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">isMount = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 更新前将workInProgressHook重制为fiber保存的第一个Hook</span></span><br><span class="line">  workInProgressHook = fiber.memoizedState;</span><br><span class="line">  <span class="comment">// 触发组件render</span></span><br><span class="line">  fiber.stateNode();</span><br><span class="line">  <span class="comment">// 首次为mount之后都是update</span></span><br><span class="line">  isMount = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件 render 时，每当遇到下一个 useState，移动 workInProgressHook 指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workInProgressHook = workInProgressHook.next;</span><br></pre></td></tr></table></figure>

<h4 id="计算-state"><a href="#计算-state" class="headerlink" title="计算 state"></a>计算 state</h4><p>render 时会调用 useState</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initiialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前useState使用hook会被赋值该变量</span></span><br><span class="line">  <span class="keyword">let</span> hook;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMount) &#123;</span><br><span class="line">    <span class="comment">// ...mount时需要生成hook对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...update时从workInProgressHook中取出该useState对应的hook</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> baseState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (hook.queue.pending) &#123;</span><br><span class="line">    <span class="comment">// ...根据queue.pending中保存的update更新state</span></span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = baseState;</span><br><span class="line">  <span class="keyword">return</span> [baseState, dispatchAction.bind(<span class="literal">null</span>.hook.queue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们找到 useState 对应的 hook 后，如果该 hook.queue.pending 不为空，则更新其 state</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hook;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMount) &#123;</span><br><span class="line">    <span class="comment">// 挂载时的</span></span><br><span class="line">    hook = &#123;</span><br><span class="line">      queue: &#123;</span><br><span class="line">        pending: <span class="literal">null</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      memoizedState: initialState,</span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 将hook插入fiber.memoizedState链表末尾</span></span><br><span class="line">    <span class="keyword">if</span> (!fiber.memoizedState) &#123;</span><br><span class="line">      fiber.memoizedState = hook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      workInProgressHook.next = hook;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动workInProgressHook指针</span></span><br><span class="line">    workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新时找到对应hook</span></span><br><span class="line">    hook = workInProgressHook;</span><br><span class="line">    <span class="comment">// 移动workInProgressHook指针</span></span><br><span class="line">    workInProgressHook = workInProgressHook.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新前初始state</span></span><br><span class="line">  <span class="keyword">let</span> baseState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (hook.queue.pending) &#123;</span><br><span class="line">    <span class="comment">// 获取update环状单向链表中第一个update</span></span><br><span class="line">    <span class="keyword">let</span> firstUpdate = hook.queue.pending.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 执行update action</span></span><br><span class="line">      <span class="keyword">const</span> action = firstUpdate.action;</span><br><span class="line">      baseState = action(baseState);</span><br><span class="line">      firstUpdate = firstUpdate.next;</span><br><span class="line">      <span class="comment">// 最后一个update执行完后跳出循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (firstUpdate !== hook.queue.pending);</span><br><span class="line">    <span class="comment">// 清空queue.pending</span></span><br><span class="line">    hook.queue.pending = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将update action执行完之后的state作为memoizedState</span></span><br><span class="line">  hook.memoizedState = baseState;</span><br><span class="line">  <span class="keyword">return</span> [baseState, dispatchAction.bind(<span class="literal">null</span>, hook.queue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="极简版与-react-区别"><a href="#极简版与-react-区别" class="headerlink" title="极简版与 react 区别"></a>极简版与 react 区别</h4><ol>
<li>React hooks 没用 ismount 变量，而是在不同时机使用不同的 dispatcher</li>
<li>React hooks 有中途跳过更新的优化手段</li>
<li>React hooks 有 batchedUpdates，三次更新只触发一次</li>
<li>React hooks 的 update 有优先级概念，可以跳过不高优先级的 update</li>
</ol>
<h3 id="hooks-数据结构"><a href="#hooks-数据结构" class="headerlink" title="hooks 数据结构"></a>hooks 数据结构</h3><h4 id="dispatcher"><a href="#dispatcher" class="headerlink" title="dispatcher"></a>dispatcher</h4><p>react hooks 中，组件 mount 时的 hook 与 update 的 hook 来源不同的对象，这类对象在源码中被称为 dispatcher</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount时的Dispatcher</span></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;</span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState,</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update时的Dispatcher</span></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate: Dispatcher = &#123;</span><br><span class="line">  useCallback: updateCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: updateEffect,</span><br><span class="line">  useImperativeHandle: updateImperativeHandle,</span><br><span class="line">  useLayoutEffect: updateLayoutEffect,</span><br><span class="line">  useMemo: updateMemo,</span><br><span class="line">  useReducer: updateReducer,</span><br><span class="line">  useRef: updateRef,</span><br><span class="line">  useState: updateState,</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>FC 的 render 前，会根据 FC 对应的 fiber 的以下条件区分 mount 和 update</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>并将不同情况对应的 dispatcher 赋值给全局变量 ReactCurrentDispathcer 的 current 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current =</span><br><span class="line">  current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">    ? HooksDispatcherOnMount</span><br><span class="line">    : HooksDispatcherOnUpdate;</span><br></pre></td></tr></table></figure>

<h4 id="hook-数据结构"><a href="#hook-数据结构" class="headerlink" title="hook 数据结构"></a>hook 数据结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">  memoizedState: <span class="literal">null</span>,</span><br><span class="line">  baseState: <span class="literal">null</span>,</span><br><span class="line">  baseQueue: <span class="literal">null</span>,</span><br><span class="line">  queue: <span class="literal">null</span>,</span><br><span class="line">  next: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="useState-与-useReducer"><a href="#useState-与-useReducer" class="headerlink" title="useState 与 useReducer"></a>useState 与 useReducer</h3><p>本质来说，useState 只是预置了 reducer 的 useReducer</p>
<h4 id="声明阶段"><a href="#声明阶段" class="headerlink" title="声明阶段"></a>声明阶段</h4><p>当 FC 进入 render 阶段的 beginWork 时，会调用 renderWithHooks，该方法内部会执行 FC 对应函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, initialArg, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useReducer(reducer, initialArg, init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mount-时-1"><a href="#mount-时-1" class="headerlink" title="mount 时"></a>mount 时</h5><p>mount 时, useReducer 会调用 mountReducer, useState 会调用 mountState</p>
<p>对比</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并返回当前hook</span></span><br><span class="line">    <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...赋值初始state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建queue</span></span><br><span class="line">    <span class="keyword">const</span> queue = (hook.queue = &#123;</span><br><span class="line">      pending: <span class="literal">null</span>,</span><br><span class="line">      dispatch: <span class="literal">null</span>,</span><br><span class="line">      lastRenderedReducer: basicStateReducer,</span><br><span class="line">      lastRenderedState: (initialState: <span class="built_in">any</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...创建dispatch</span></span><br><span class="line">    <span class="keyword">return</span> [hook.memoizedState, dispatch]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialArg: I,</span></span></span><br><span class="line"><span class="function"><span class="params">  init?: I =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;] </span>&#123;</span><br><span class="line">  <span class="comment">// 创建并返回当前的hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...赋值初始state</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建queue</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.queue = &#123;</span><br><span class="line">    <span class="comment">// 保存update对象</span></span><br><span class="line">    pending: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 保存dispatchAction.bind()的值</span></span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 上一次render时使用的reducer</span></span><br><span class="line">    lastRenderedReducer: reducer,</span><br><span class="line">    <span class="comment">// 上一次render时的state</span></span><br><span class="line">    lastRenderedState: (initialState: <span class="built_in">any</span>),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...创建dispatch</span></span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个 hook 唯一区别是 queue 的 lastRenderedReducer 字段。</p>
<p>basicStateReducer</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>&lt;<span class="title">S</span>&gt;(<span class="params">state: S, action: BasicStateAction&lt;S&gt;</span>): <span class="title">S</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">"function"</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="update-时-1"><a href="#update-时-1" class="headerlink" title="update 时"></a>update 时</h5><p>两者调用的是同一个 updateReducer</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialArg: I,</span></span></span><br><span class="line"><span class="function"><span class="params">  init?: I =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;] </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgress();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line"></span><br><span class="line">  queue.lastRenderedReducer = reducer;</span><br><span class="line">   <span class="comment">// ...同update与updateQueue逻辑类似</span></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用阶段"><a href="#调用阶段" class="headerlink" title="调用阶段"></a>调用阶段</h4><p>调用阶段会执行 dispatchAction，此时 FC 对应的 fiber 以及 hook.queue 以及通过 bind 方法预先最为参数传入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>(<span class="params">fiber, queue, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...创建update</span></span><br><span class="line">  <span class="keyword">var</span> update = &#123;</span><br><span class="line">    eventTime,</span><br><span class="line">    lane,</span><br><span class="line">    suspenseConfig,</span><br><span class="line">    action,</span><br><span class="line">    eagerReducer: <span class="literal">null</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...将update加入queue.pending</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> alternate = fiber.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber$<span class="number">1</span> ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber$<span class="number">1</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// render阶段触发的更新</span></span><br><span class="line">    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      fiber.lanes === NoLanes &amp;&amp;</span><br><span class="line">      (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// ...fiber的updateQueue为空，优化路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scheduleUpdateOnFiber(fiber, lane, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程概括：创建 update，将 update 加入 queue.pending 中，并开启调度。</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><h4 id="flushPassiveEffectsImpl"><a href="#flushPassiveEffectsImpl" class="headerlink" title="flushPassiveEffectsImpl"></a>flushPassiveEffectsImpl</h4><p>flushPassiveEffects 内部会设置优先级，并执行 flushPassiveEffectsImpl</p>
<p>flushPassiveEffectsImpl 主要做 3 件事：</p>
<ul>
<li>调用该 useEffect 在上一次 render 时的销毁函数</li>
<li>调用该 useEffect 在本次 render 时的回调函数</li>
<li>如果存在同步任务，不需要等待下次事件循环的宏任务，提前执行他</li>
</ul>
<blockquote>
<p>副作用清理函数在 V16 中同步运行，对大型应用程序来说，会减缓屏幕的过度</p>
</blockquote>
<p>V17，useEffect 的两个阶段会在页面渲染后异步执行。</p>
<h4 id="销毁函数的执行"><a href="#销毁函数的执行" class="headerlink" title="销毁函数的执行"></a>销毁函数的执行</h4><p>useEffect 的执行需要保证所有组件的 useEffect 的销毁函数必须都执行完之后才能执行任意一个组件的 useEffect 的回调函数。这时因为多个组件间可能共用同一个 ref。</p>
<p>都遵循全部销毁再全部执行的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pengdingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect</span></span><br><span class="line"><span class="keyword">const</span> unmountEffects = pendingPassiveHookEffectsUnmount;</span><br><span class="line">pendingPassiveHookEffectsUnmount = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; unmountEffects.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effect = ((unmountEffects[i]: any): HookEffect);</span><br><span class="line">  <span class="keyword">const</span> fiber = ((unmountEffects[i + <span class="number">1</span>]: any): Fiber);</span><br><span class="line">  <span class="keyword">const</span> destroy = effect.destroy;</span><br><span class="line">  effect.destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> destroy === <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="comment">// 销毁函数存在则执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      destroy();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(fiber, error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedulePassiveEffects</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateQueue: FunctionComponentUpdateQueue | <span class="literal">null</span> = (finishedWork.updateQueue: <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">const</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.lastEffect: <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> firstEffect = lastEffect.next;</span><br><span class="line">    <span class="keyword">let</span> effect = firstEffect;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;next, tag&#125; = effect;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (tag &amp; HookPassive) !== NoHookEffect &amp;&amp;</span><br><span class="line">        (tag &amp; HookHasEffect) !== NoHookEffect</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect</span></span><br><span class="line">        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);</span><br><span class="line">        <span class="comment">// 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect</span></span><br><span class="line">        enqueuePendingPassiveHookEffectMount(finishedWork, effect);</span><br><span class="line">      &#125;</span><br><span class="line">      effect = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回调函数执行"><a href="#回调函数执行" class="headerlink" title="回调函数执行"></a>回调函数执行</h4><p>遍历数组，执行对应 effect 的回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect</span></span><br><span class="line"><span class="keyword">const</span> mountEffects = pendingPassiveHookEffectsMount;</span><br><span class="line">pendingPassiveHookEffectsMount = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mountEffects.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effect = ((mountEffects[i]: any): HookEffect);</span><br><span class="line">  <span class="keyword">const</span> fiber = ((mountEffects[i + <span class="number">1</span>]: any): Fiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> create = effect.create;</span><br><span class="line">    effect.destroy = create();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    captureCommitPhaseError(fiber, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// |current: T| ???</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;|current: T|&#125; &#123;</span><br><span class="line">  <span class="comment">// 获取当前useRef hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 创建ref</span></span><br><span class="line">  <span class="keyword">const</span> ref = &#123; <span class="attr">current</span>: initialValue &#125;;</span><br><span class="line">  hook.memorized = ref;</span><br><span class="line">  <span class="keyword">return</span> ref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;|current: T|&#125; &#123;</span><br><span class="line">  <span class="comment">// 获取当前useRef hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 返回保存的数据</span></span><br><span class="line">  reutrn hook.memoizedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params"></span>): <span class="title">RefObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    current: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="render-阶段-1"><a href="#render-阶段-1" class="headerlink" title="render 阶段"></a>render 阶段</h4><p>在 render 阶段的 beginWork 与 completeWork 中有个同名方法 markRef 用于为含有 ref 属性的 fiber 增加 Ref effectTag。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beginWork的markRef</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRef</span>(<span class="params">current: Fiber | null, workInProgress: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = workInProgress.ref;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (current === <span class="literal">null</span> &amp;&amp; ref !== <span class="literal">null</span>) ||</span><br><span class="line">    (current !== <span class="literal">null</span> &amp;&amp; current.ref !== ref)</span><br><span class="line">  ) &#123;</span><br><span class="line">    workInProgress.effectTag |= Ref;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// completeWork的markRef</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRef</span>(<span class="params">workInProgress: Fiber</span>) </span>&#123;</span><br><span class="line">  workInProgress.effectTag |= Ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件对应的 fiber 被赋值 Ref effectTag 需要满足的条件：</p>
<ul>
<li>fiber 类型为 HostComponent、ClassComponent、ScopeComponent</li>
<li>对于 mount, workInProgress.ref !== null,即存在 ref 属性</li>
<li>对于 update, current.ref !== workInProgress.ref ，即 ref 属性改变</li>
</ul>
<h4 id="commit-阶段-1"><a href="#commit-阶段-1" class="headerlink" title="commit 阶段"></a>commit 阶段</h4><p>在 commit 阶段的 mutation 阶段，对于 ref 属性改变的情况，需要先移除之前的 ref</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params">root: FiberRoot, renderPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除之前ref</span></span><br><span class="line">        commitDetachRef(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDetachRef</span>(<span class="params">current: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentRef = current.ref;</span><br><span class="line">  <span class="keyword">if</span> (currentRef !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> currentRef === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="comment">// function类型ref, 调用他，传参为null</span></span><br><span class="line">      currentRef(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对象类型ref, current赋值为null</span></span><br><span class="line">      currentRef.current = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useMemo-与-useCallback"><a href="#useMemo-与-useCallback" class="headerlink" title="useMemo 与 useCallback"></a>useMemo 与 useCallback</h3><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: (</span>) =&gt; <span class="title">T</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span></span></span><br><span class="line"><span class="function">): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建并返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 计算value</span></span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line">  <span class="comment">// 将value与deps保存在hook.memoizedState</span></span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建并返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// 将value与deps保存在hook.memoizedState</span></span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 mountCallback 这两个唯一区别是</p>
<ul>
<li>mountMemo 会将回调函数的执行结果作为 value 保存</li>
<li>mountCallback 会保存回调函数结果作为 value 保存</li>
</ul>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: (</span>) =&gt; <span class="title">T</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span></span></span><br><span class="line"><span class="function">): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 判断update前后value是否变化</span></span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="comment">// 未变化</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 变化，重新计算value</span></span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回当前hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 判断update前后value是否变化</span></span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="comment">// 未变化</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 变化，将新的callback作为value</span></span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h2><p>Scheduler，含两个功能：</p>
<ol>
<li>时间切片</li>
<li>优先级调度</li>
</ol>
<h3 id="时间切片原理"><a href="#时间切片原理" class="headerlink" title="时间切片原理"></a>时间切片原理</h3><p>本质是模拟实现<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener">requesrIdleCallback</a></p>
<p>除去浏览器重排重绘，下图是浏览器一帧中可以用于执行 js 的时机。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback</span><br></pre></td></tr></table></figure>

<p>requestAnimationFrame 让我们可以在浏览器重排重绘之前执行 js。</p>
<p>我们通常使用这个 api 实现 js 动画，这时浏览器渲染前的最后时机。</p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>Scheduler 对外暴露一个方法 unstable_runWithPriority</p>
<p>这个方法接受一个优先级与一个回调函数，在回调函数内部调用获取优先级的方法都会取得第一个参数对应的优先级：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      priorityLevel = NormalPriority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eventHandler();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lane"><a href="#lane" class="headerlink" title="lane"></a>lane</h4><p>使用 31 位二进制代表 31 条赛道，位数越小的赛道优先级越高，某些相邻的赛道拥有相同优先级</p>
<p>越低优先级的更新越容易被打断，导致积压下来，所以需要更多的位。</p>
<p>优先级运算-位运算</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/wangqinyong1994/blog/2020/11/29/react原理/" data-id="ckonxgfb3001e78yzsli7bjoj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2020/12/30/java基础/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java基础
        
      </div>
    </a>
  
  
    <a href="/blog/2020/10/14/设计模式/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">前端路线</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Chrome/">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/qiankun-微前端-umi/">qiankun 微前端 umi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/vscode-eslint-prettier/">vscode eslint prettier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/上卷-this-原型对象/">上卷 this 原型对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/上卷-作用域和闭包/">上卷 作用域和闭包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/上卷-对象/">上卷 对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/中卷-异步与性能/">中卷 异步与性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/中卷-类型-值/">中卷 类型 值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/你不知道的JavaScript/">你不知道的JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/前端-工程化-npm/">前端 工程化 npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/前端-设计模式/">前端 设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/单点登录-SSO/">单点登录 SSO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/序/">序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/测试/">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/blog/tags/Java/" style="font-size: 20px;">Java</a> <a href="/blog/tags/React/" style="font-size: 10px;">React</a> <a href="/blog/tags/qiankun-微前端-umi/" style="font-size: 10px;">qiankun 微前端 umi</a> <a href="/blog/tags/vscode-eslint-prettier/" style="font-size: 10px;">vscode eslint prettier</a> <a href="/blog/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/blog/tags/上卷-this-原型对象/" style="font-size: 10px;">上卷 this 原型对象</a> <a href="/blog/tags/上卷-作用域和闭包/" style="font-size: 10px;">上卷 作用域和闭包</a> <a href="/blog/tags/上卷-对象/" style="font-size: 10px;">上卷 对象</a> <a href="/blog/tags/中卷-异步与性能/" style="font-size: 10px;">中卷 异步与性能</a> <a href="/blog/tags/中卷-类型-值/" style="font-size: 10px;">中卷 类型 值</a> <a href="/blog/tags/你不知道的JavaScript/" style="font-size: 10px;">你不知道的JavaScript</a> <a href="/blog/tags/前端-工程化-npm/" style="font-size: 10px;">前端 工程化 npm</a> <a href="/blog/tags/前端-设计模式/" style="font-size: 10px;">前端 设计模式</a> <a href="/blog/tags/单点登录-SSO/" style="font-size: 10px;">单点登录 SSO</a> <a href="/blog/tags/序/" style="font-size: 10px;">序</a> <a href="/blog/tags/测试/" style="font-size: 10px;">测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2021/03/26/测试相关/">测试相关</a>
          </li>
        
          <li>
            <a href="/blog/2021/03/24/headless-chrome/">headless chrome</a>
          </li>
        
          <li>
            <a href="/blog/2021/03/24/java高级/">Java高级</a>
          </li>
        
          <li>
            <a href="/blog/2021/02/03/SSO实践/">SSO实践</a>
          </li>
        
          <li>
            <a href="/blog/2021/02/03/微前端实践/">微前端实践</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 WangQinyong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>